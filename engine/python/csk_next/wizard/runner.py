"""Wizard runtime orchestration."""

from __future__ import annotations

from pathlib import Path
import sys
from typing import Any

from csk_next.domain.state import ensure_registry, find_module
from csk_next.runtime.config import load_local_config
from csk_next.runtime.intake import classify_request
from csk_next.runtime.missions import mission_new
from csk_next.runtime.modules import module_add, module_init
from csk_next.runtime.paths import Layout
from csk_next.runtime.tasks_engine import add_decision, task_new
from csk_next.wizard.store import (
    append_event,
    load_result,
    load_session,
    save_result,
    save_session,
    start_session,
)


def _module_mapping_suggestions(layout: Layout, classification: str) -> list[dict[str, Any]]:
    registry = ensure_registry(layout.registry)
    modules = sorted(registry["modules"], key=lambda row: str(row.get("module_id", "")))
    if not modules:
        return []

    if classification == "multi_module_mission":
        selected = modules
    else:
        preferred = [row for row in modules if str(row.get("module_id", "")) == "root"]
        selected = preferred or [modules[0]]

    suggestions: list[dict[str, Any]] = []
    for module in selected:
        module_id = str(module["module_id"])
        module_path = str(module["path"])
        suggestions.append(
            {
                "module_id": module_id,
                "path": module_path,
                "token": module_id,
                "reason": "Suggested from registered modules based on intake classification.",
                "requires_explicit_confirm": True,
            }
        )
    return suggestions


def _parse_module_mapping(raw: str) -> list[tuple[str, str | None]]:
    mappings: list[tuple[str, str | None]] = []
    for token in [part.strip() for part in raw.split(",") if part.strip()]:
        if ":" in token:
            module_id, module_path = token.split(":", 1)
            module_id = module_id.strip()
            module_path = module_path.strip()
            if not module_id or not module_path:
                raise ValueError(f"Invalid module mapping token: {token}")
            mappings.append((module_id, module_path))
        else:
            mappings.append((token, None))
    if not mappings:
        raise ValueError("At least one module mapping is required")
    return mappings


def _ensure_modules(layout: Layout, mappings: list[tuple[str, str | None]]) -> list[str]:
    registry = ensure_registry(layout.registry)
    selected: list[str] = []
    for module_id, module_path in mappings:
        existing = None
        for module in registry["modules"]:
            if module["module_id"] == module_id:
                existing = module
                break
        if existing is None:
            if module_path is None:
                raise ValueError(
                    f"Module '{module_id}' does not exist; provide explicit path as module_id:path"
                )
            module_add(layout, module_path, module_id)
            module_init(layout, module_id)
        else:
            if not existing.get("initialized", False):
                module_init(layout, module_id)
        selected.append(module_id)
    return selected


def _shape_from_answer(answer: str, classification: str) -> str:
    normalized = answer.strip().lower()
    if normalized == "auto":
        return "multi" if classification == "multi_module_mission" else "single"
    if normalized not in {"single", "multi"}:
        raise ValueError("Shape must be one of: single, multi, auto")
    return normalized


def _materialize(layout: Layout, session_id: str, context: dict[str, Any]) -> dict[str, Any]:
    selected_modules: list[str] = list(context.get("selected_modules", []))
    if not selected_modules:
        raise ValueError("No modules selected")

    request = str(context.get("request", "")).strip()
    title = request[:96] if request else "CSK Mission"
    summary = request if request else "Generated by wizard"
    shape = str(context.get("shape", "single"))
    option = str(context.get("planning_option", "B"))

    local_config = load_local_config(layout)
    default_profile = str(local_config.get("default_profile", "default"))
    worktree_default = bool(local_config.get("worktree_default", True))

    if shape == "single":
        module_id = selected_modules[0]
        registry = ensure_registry(layout.registry)
        module = find_module(registry, module_id)
        result = task_new(
            layout=layout,
            module_id=module_id,
            module_path=module["path"],
            mission_id=None,
            profile=default_profile,
            max_attempts=2,
            plan_template=(
                f"# Plan ({option})\n\n"
                f"## Request\n{summary}\n\n"
                "## Scope\n- TODO\n\n"
                "## Non-scope\n- TODO\n\n"
                "## Slices\n- S-0001\n"
            ),
        )
        add_decision(
            layout=layout,
            module_path=module["path"],
            task_id=result["task_id"],
            decision=f"Wizard selected planning option {option}",
            rationale="User-confirmed run flow",
            decided_by="wizard",
        )
        payload = {
            "kind": "single_module_task",
            "session_id": session_id,
            "request": summary,
            "shape": shape,
            "planning_option": option,
            "artifacts": {
                "task_id": result["task_id"],
                "task_path": result["task_path"],
                "module_id": module_id,
                "plan_path": str(Path(result["task_path"]) / "plan.md"),
                "slices_path": str(Path(result["task_path"]) / "slices.json"),
                "decisions_path": str(Path(result["task_path"]) / "decisions.jsonl"),
            },
        }
        save_result(layout, session_id, payload)
        return payload

    mission = mission_new(
        layout=layout,
        title=title,
        summary=summary,
        module_ids=selected_modules,
        create_worktrees=worktree_default,
        create_task_stubs=True,
        profile=default_profile,
    )
    payload = {
        "kind": "multi_module_mission",
        "session_id": session_id,
        "request": summary,
        "shape": shape,
        "planning_option": option,
        "artifacts": {
            "mission_id": mission["mission_id"],
            "mission_path": mission["path"],
            "milestone_id": "MS-0001",
            "routing_path": str(Path(mission["path"]) / "routing.json"),
            "milestones_path": str(Path(mission["path"]) / "milestones.json"),
            "worktrees_path": str(Path(mission["path"]) / "worktrees.json"),
            "tasks_created": mission["tasks_created"],
            "modules": selected_modules,
        },
    }
    save_result(layout, session_id, payload)
    return payload


def wizard_start(layout: Layout) -> dict[str, Any]:
    session = start_session(layout)
    return wizard_status(layout, session.session_id)


def _step_payload(step: dict[str, Any], context: dict[str, Any]) -> dict[str, Any]:
    payload = dict(step)
    if str(payload.get("step_id")) != "module_mapping":
        return payload

    suggestions = context.get("module_mapping_suggestions")
    if isinstance(suggestions, list):
        payload["suggestions"] = suggestions
    recommended = context.get("module_mapping_recommended")
    if isinstance(recommended, str) and recommended.strip():
        payload["recommended"] = recommended.strip()
    payload["unchanged"] = [
        "Suggestions are hints only",
        "Only explicit module mapping input is materialized",
    ]
    return payload


def wizard_status(layout: Layout, session_id: str) -> dict[str, Any]:
    session = load_session(layout, session_id)
    result = load_result(layout, session_id)
    current = session.current_step
    step = _step_payload(current.to_dict(), session.context) if current is not None else None
    return {
        "status": "ok",
        "wizard": {
            "session_id": session.session_id,
            "session_status": session.status,
            "current_step_index": session.current_step_index,
            "step": step,
            "context": session.context,
            "result": result,
        },
    }


def wizard_answer(layout: Layout, session_id: str, response: str) -> dict[str, Any]:
    session = load_session(layout, session_id)
    if session.is_completed:
        return wizard_status(layout, session_id)

    step = session.current_step
    if step is None:
        session.status = "completed"
        save_session(layout, session)
        return wizard_status(layout, session_id)

    append_event(
        layout,
        session_id,
        {
            "event": "answer",
            "step_id": step.step_id,
            "response": response,
        },
    )

    if step.step_id == "intake_request":
        request_text = response.strip()
        if not request_text:
            raise ValueError("Task request cannot be empty")
        registry = ensure_registry(layout.registry)
        module_ids = [item["module_id"] for item in registry["modules"]]
        classification = classify_request(request_text, module_ids)["classification"]
        suggestions = _module_mapping_suggestions(layout, classification)
        session.context["request"] = request_text
        session.context["classification"] = classification
        session.context["module_mapping_suggestions"] = suggestions
        if suggestions:
            session.context["module_mapping_recommended"] = ",".join(str(item["token"]) for item in suggestions)
        append_event(
            layout,
            session_id,
            {
                "event": "module_mapping_suggested",
                "classification": classification,
                "suggestions": suggestions,
            },
        )

    elif step.step_id == "module_mapping":
        mappings = _parse_module_mapping(response)
        selected = _ensure_modules(layout, mappings)
        session.context["selected_modules"] = selected

    elif step.step_id == "execution_shape":
        classification = str(session.context.get("classification", "single_module_task"))
        session.context["shape"] = _shape_from_answer(response, classification)

    elif step.step_id == "planning_option":
        option = response.strip().upper()
        if option not in {"A", "B", "C"}:
            raise ValueError("Planning option must be A, B, or C")
        session.context["planning_option"] = option

    elif step.step_id == "confirm_materialization":
        decision = response.strip().lower()
        if decision not in {"yes", "no"}:
            raise ValueError("Confirmation must be yes or no")
        if decision == "no":
            session.status = "cancelled"
            save_session(layout, session)
            append_event(layout, session_id, {"event": "cancelled"})
            return wizard_status(layout, session_id)

        materialized = _materialize(layout, session_id, session.context)
        session.status = "completed"
        session.current_step_index = len(session.steps)
        save_session(layout, session)
        append_event(layout, session_id, {"event": "completed", "result_kind": materialized["kind"]})
        return wizard_status(layout, session_id)

    session.current_step_index += 1
    if session.current_step_index >= len(session.steps):
        session.status = "completed"
    save_session(layout, session)
    return wizard_status(layout, session_id)


def run_wizard(
    *,
    layout: Layout,
    scripted_answers: dict[str, str] | None,
    non_interactive: bool,
) -> dict[str, Any]:
    started = wizard_start(layout)
    wizard = started["wizard"]
    session_id = wizard["session_id"]

    while True:
        view = wizard_status(layout, session_id)
        wizard_data = view["wizard"]
        if wizard_data["session_status"] in {"completed", "cancelled"}:
            return view

        step = wizard_data["step"]
        if step is None:
            return view
        step_id = str(step["step_id"])
        if isinstance(scripted_answers, dict) and step_id in scripted_answers:
            wizard_answer(layout, session_id, str(scripted_answers[step_id]))
            continue

        if non_interactive or not sys.stdin.isatty():
            session = load_session(layout, session_id)
            missing_steps = [row.step_id for row in session.steps[session.current_step_index :]]
            return {
                "status": "failed",
                "wizard": wizard_data,
                "error": "wizard requires additional answers",
                "missing_steps": missing_steps,
            }

        print(f"\n[{step['title']}] {step['prompt']}")
        if step["options"]:
            for item in step["options"]:
                print(f"- {item['value']}: {item['label']} ({item['description']})")
        if step.get("recommended"):
            print(f"recommended: {step['recommended']}")
        if step.get("unchanged"):
            print("unchanged:")
            for row in step["unchanged"]:
                print(f"  - {row}")
        if step.get("suggestions"):
            print("suggestions:")
            for row in step["suggestions"]:
                token = row.get("token")
                module_id = row.get("module_id")
                module_path = row.get("path")
                reason = row.get("reason")
                print(f"  - {token} (module={module_id}, path={module_path}) :: {reason}")
        print(f"input hint: {step['input_hint']}")

        answer = input("> ").strip()
        wizard_answer(layout, session_id, answer)
