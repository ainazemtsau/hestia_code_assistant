"""Wizard runtime orchestration."""

from __future__ import annotations

from typing import Any

from csk_next.domain.state import ensure_registry, find_module
from csk_next.runtime.config import load_local_config
from csk_next.runtime.intake import classify_request
from csk_next.runtime.missions import mission_new
from csk_next.runtime.modules import module_add, module_init
from csk_next.runtime.paths import Layout
from csk_next.runtime.tasks_engine import add_decision, task_new
from csk_next.wizard.store import (
    append_event,
    load_result,
    load_session,
    save_result,
    save_session,
    start_session,
)


def _parse_module_mapping(raw: str) -> list[tuple[str, str | None]]:
    mappings: list[tuple[str, str | None]] = []
    for token in [part.strip() for part in raw.split(",") if part.strip()]:
        if ":" in token:
            module_id, module_path = token.split(":", 1)
            module_id = module_id.strip()
            module_path = module_path.strip()
            if not module_id or not module_path:
                raise ValueError(f"Invalid module mapping token: {token}")
            mappings.append((module_id, module_path))
        else:
            mappings.append((token, None))
    if not mappings:
        raise ValueError("At least one module mapping is required")
    return mappings


def _ensure_modules(layout: Layout, mappings: list[tuple[str, str | None]]) -> list[str]:
    registry = ensure_registry(layout.registry)
    selected: list[str] = []
    for module_id, module_path in mappings:
        existing = None
        for module in registry["modules"]:
            if module["module_id"] == module_id:
                existing = module
                break
        if existing is None:
            if module_path is None:
                raise ValueError(
                    f"Module '{module_id}' does not exist; provide explicit path as module_id:path"
                )
            module_add(layout, module_path, module_id)
            module_init(layout, module_id)
        else:
            if not existing.get("initialized", False):
                module_init(layout, module_id)
        selected.append(module_id)
    return selected


def _shape_from_answer(answer: str, classification: str) -> str:
    normalized = answer.strip().lower()
    if normalized == "auto":
        return "multi" if classification == "multi_module_mission" else "single"
    if normalized not in {"single", "multi"}:
        raise ValueError("Shape must be one of: single, multi, auto")
    return normalized


def _materialize(layout: Layout, session_id: str, context: dict[str, Any]) -> dict[str, Any]:
    selected_modules: list[str] = list(context.get("selected_modules", []))
    if not selected_modules:
        raise ValueError("No modules selected")

    request = str(context.get("request", "")).strip()
    title = request[:96] if request else "CSK Mission"
    summary = request if request else "Generated by wizard"
    shape = str(context.get("shape", "single"))
    option = str(context.get("planning_option", "B"))

    local_config = load_local_config(layout)
    default_profile = str(local_config.get("default_profile", "default"))
    worktree_default = bool(local_config.get("worktree_default", True))

    if shape == "single":
        module_id = selected_modules[0]
        registry = ensure_registry(layout.registry)
        module = find_module(registry, module_id)
        result = task_new(
            layout=layout,
            module_id=module_id,
            module_path=module["path"],
            mission_id=None,
            profile=default_profile,
            max_attempts=2,
            plan_template=(
                f"# Plan ({option})\n\n"
                f"## Request\n{summary}\n\n"
                "## Scope\n- TODO\n\n"
                "## Non-scope\n- TODO\n\n"
                "## Slices\n- S-0001\n"
            ),
        )
        add_decision(
            layout=layout,
            module_path=module["path"],
            task_id=result["task_id"],
            decision=f"Wizard selected planning option {option}",
            rationale="User-confirmed run flow",
            decided_by="wizard",
        )
        payload = {
            "kind": "single_module_task",
            "session_id": session_id,
            "planning_option": option,
            "artifacts": {
                "task_id": result["task_id"],
                "task_path": result["task_path"],
                "module_id": module_id,
            },
        }
        save_result(layout, session_id, payload)
        return payload

    mission = mission_new(
        layout=layout,
        title=title,
        summary=summary,
        module_ids=selected_modules,
        create_worktrees=worktree_default,
        create_task_stubs=True,
        profile=default_profile,
    )
    payload = {
        "kind": "multi_module_mission",
        "session_id": session_id,
        "planning_option": option,
        "artifacts": {
            "mission_id": mission["mission_id"],
            "mission_path": mission["path"],
            "tasks_created": mission["tasks_created"],
            "modules": selected_modules,
        },
    }
    save_result(layout, session_id, payload)
    return payload


def wizard_start(layout: Layout) -> dict[str, Any]:
    session = start_session(layout)
    return wizard_status(layout, session.session_id)


def wizard_status(layout: Layout, session_id: str) -> dict[str, Any]:
    session = load_session(layout, session_id)
    result = load_result(layout, session_id)
    current = session.current_step
    return {
        "status": "ok",
        "wizard": {
            "session_id": session.session_id,
            "session_status": session.status,
            "current_step_index": session.current_step_index,
            "step": current.to_dict() if current is not None else None,
            "context": session.context,
            "result": result,
        },
    }


def wizard_answer(layout: Layout, session_id: str, response: str) -> dict[str, Any]:
    session = load_session(layout, session_id)
    if session.is_completed:
        return wizard_status(layout, session_id)

    step = session.current_step
    if step is None:
        session.status = "completed"
        save_session(layout, session)
        return wizard_status(layout, session_id)

    append_event(
        layout,
        session_id,
        {
            "event": "answer",
            "step_id": step.step_id,
            "response": response,
        },
    )

    if step.step_id == "intake_request":
        request_text = response.strip()
        if not request_text:
            raise ValueError("Task request cannot be empty")
        registry = ensure_registry(layout.registry)
        module_ids = [item["module_id"] for item in registry["modules"]]
        classification = classify_request(request_text, module_ids)["classification"]
        session.context["request"] = request_text
        session.context["classification"] = classification

    elif step.step_id == "module_mapping":
        mappings = _parse_module_mapping(response)
        selected = _ensure_modules(layout, mappings)
        session.context["selected_modules"] = selected

    elif step.step_id == "execution_shape":
        classification = str(session.context.get("classification", "single_module_task"))
        session.context["shape"] = _shape_from_answer(response, classification)

    elif step.step_id == "planning_option":
        option = response.strip().upper()
        if option not in {"A", "B", "C"}:
            raise ValueError("Planning option must be A, B, or C")
        session.context["planning_option"] = option

    elif step.step_id == "confirm_materialization":
        decision = response.strip().lower()
        if decision not in {"yes", "no"}:
            raise ValueError("Confirmation must be yes or no")
        if decision == "no":
            session.status = "cancelled"
            save_session(layout, session)
            append_event(layout, session_id, {"event": "cancelled"})
            return wizard_status(layout, session_id)

        materialized = _materialize(layout, session_id, session.context)
        session.status = "completed"
        session.current_step_index = len(session.steps)
        save_session(layout, session)
        append_event(layout, session_id, {"event": "completed", "result_kind": materialized["kind"]})
        return wizard_status(layout, session_id)

    session.current_step_index += 1
    if session.current_step_index >= len(session.steps):
        session.status = "completed"
    save_session(layout, session)
    return wizard_status(layout, session_id)


def run_wizard(
    *,
    layout: Layout,
    request: str | None,
    modules: str | None,
    shape: str | None,
    plan_option: str | None,
    auto_confirm: bool,
    non_interactive: bool,
) -> dict[str, Any]:
    started = wizard_start(layout)
    wizard = started["wizard"]
    session_id = wizard["session_id"]

    scripted_answers: list[str] = []
    if request is not None:
        scripted_answers.append(request)
    if modules is not None:
        scripted_answers.append(modules)
    if shape is not None:
        scripted_answers.append(shape)
    if plan_option is not None:
        scripted_answers.append(plan_option)
    if auto_confirm:
        scripted_answers.append("yes")

    for answer in scripted_answers:
        started = wizard_answer(layout, session_id, answer)

    status = started["wizard"]["session_status"]
    if status in {"completed", "cancelled"}:
        return started

    if non_interactive:
        return {
            "status": "failed",
            "wizard": started["wizard"],
            "error": "wizard requires additional answers",
        }

    while True:
        view = wizard_status(layout, session_id)
        wizard_data = view["wizard"]
        if wizard_data["session_status"] in {"completed", "cancelled"}:
            return view

        step = wizard_data["step"]
        if step is None:
            return view

        print(f"\n[{step['title']}] {step['prompt']}")
        if step["options"]:
            for item in step["options"]:
                print(f"- {item['value']}: {item['label']} ({item['description']})")
        if step.get("recommended"):
            print(f"recommended: {step['recommended']}")
        if step.get("unchanged"):
            print("unchanged:")
            for row in step["unchanged"]:
                print(f"  - {row}")
        print(f"input hint: {step['input_hint']}")

        answer = input("> ").strip()
        wizard_answer(layout, session_id, answer)
